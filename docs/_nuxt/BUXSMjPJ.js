import{_ as E}from"./pxczNYIJ.js";import{_ as b}from"./D9-hoJGw.js";import{_ as T,a as j}from"./c6tsABtt.js";import{a as Y}from"./s0z2JT-x.js";import{T as p,c as a,_ as I,a as w,b as F}from"./tWA0xS_5.js";import{_ as L}from"./DAH-GGfd.js";import{f as x,o as v,e as P,w as s,d as n,b as o,a as r}from"./CPdTkOzn.js";import{_ as $}from"./D6leYXVZ.js";import{_ as M}from"./D9YCSiNI.js";import{_ as C}from"./1ktSNDAW.js";import{_ as S}from"./BOufzIrK.js";import{_ as J}from"./L44TgIuP.js";import{_ as N}from"./D0m3koNe.js";import{_ as V}from"./D1UsOuFE.js";import{_ as q}from"./B6alVScc.js";const mt=x({__name:"install-node-task",setup(R){const u=[{name:"nodeVersion",type:p.STRING,binding:a.PROPERTY,property:"nodeVersion"},{name:"nodeDistributionUrlRoot",type:p.STRING,binding:a.PROPERTY,property:"nodeDistributionUrlRoot"},{name:"nodeDistributionUrlPathPattern",type:p.STRING,binding:a.PROPERTY,property:"nodeDistributionUrlPathPattern"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"}],m=[{name:"nodeExecutableFile",type:p.REGULAR_FILE,binding:a.CUSTOM}];return(t,e)=>{const i=E,l=b,d=T,g=Y,f=I,k=w,y=L,D=F;return v(),P(D,{name:"installNode",inputs:u,outputs:m},{title:s(()=>[e[0]||(e[0]=n("Install ")),o(i)]),nodeExecutableFile:s(()=>[o(l,{name:"nodeInstallDirectory"}),o(d,null,{default:s(()=>e[1]||(e[1]=[n("/node.exe")])),_:1}),e[3]||(e[3]=n(" or ")),o(l,{name:"nodeInstallDirectory"}),o(d,null,{default:s(()=>e[2]||(e[2]=[n("/bin/node")])),_:1}),e[4]||(e[4]=n(" depending on the O/S. "))]),skipConditions:s(()=>[e[6]||(e[6]=n(" property ")),o(l,{name:"nodeDistributionProvided"}),e[7]||(e[7]=n(" is ")),o(d,null,{default:s(()=>e[5]||(e[5]=[n("true")])),_:1}),e[8]||(e[8]=n(". "))]),description:s(()=>[r("p",null,[e[14]||(e[14]=n(" The task downloads a ")),o(i),e[15]||(e[15]=n(" distribution, verifies its integrity, and installs it in the directory pointed by the ")),o(l,{name:"nodeInstallDirectory"}),e[16]||(e[16]=n(" property. The URL used to download the distribution is resolved using the ")),o(l,{name:"nodeDistributionUrlRoot"}),e[17]||(e[17]=n(" property and the ")),o(l,{name:"nodeDistributionUrlPathPattern"}),e[18]||(e[18]=n(" property. Checking the distribution integrity consists of downloading a file providing the distribution shasum. This file is expected to be in the same remote web directory than the distribution archive. For example, if the distribution is located at ")),o(d,null,{default:s(()=>e[9]||(e[9]=[n("https://nodejs.org/dist/vX.Y.Z/node-vX.Y.Z-win-x64.zip")])),_:1}),e[19]||(e[19]=n(", the plugin attempts to download the shasum file located at ")),o(d,null,{default:s(()=>e[10]||(e[10]=[n("https://nodejs.org/dist/vX.Y.Z/SHASUMS256.txt")])),_:1}),e[20]||(e[20]=n(". By default, the plugin relies on the VM ")),o(g,null,{default:s(()=>e[11]||(e[11]=[n("network properties")])),_:1}),e[21]||(e[21]=n(" to know if a proxy server shall be used when downloading the distribution and the shasum. A custom proxy server may also be used by defining ")),o(l,{name:"httpsProxyHost"}),e[22]||(e[22]=n(" property (respectively ")),o(l,{name:"httpProxyHost"}),e[23]||(e[23]=n(" property) if the ")),o(l,{name:"nodeDistributionUrlRoot"}),e[24]||(e[24]=n(" property uses the ")),o(d,null,{default:s(()=>e[12]||(e[12]=[n("https")])),_:1}),e[25]||(e[25]=n(" protocol (resp. uses the ")),o(d,null,{default:s(()=>e[13]||(e[13]=[n("http")])),_:1}),e[26]||(e[26]=n(" protocol). In case of connectivity/HTTP error, download of the distribution file and the shasum file may be retried using property ")),o(l,{name:"maxDownloadAttempts"}),e[27]||(e[27]=n(". "))]),r("p",null,[e[29]||(e[29]=n(" If a ")),o(i),e[30]||(e[30]=n(" distribution is already installed in the system, either as a global installation or as an installation performed by another Gradle (sub-)project, and shall be used instead of a downloaded distribution, take a look at the ")),o(l,{name:"nodeDistributionProvided"}),e[31]||(e[31]=n(" property instead: when ")),o(d,null,{default:s(()=>e[28]||(e[28]=[n("true")])),_:1}),e[32]||(e[32]=n(", this task is ignored if invoked during a Gradle build, and its outcome will always be ")),o(f,{outcome:"SKIPPED"}),e[33]||(e[33]=n(". "))]),r("p",null,[e[35]||(e[35]=n(" The task takes advantage of ")),o(k,{path:"/performance/#incremental_build"},{default:s(()=>e[34]||(e[34]=[n("Gradle incremental build")])),_:1}),e[36]||(e[36]=n(", and is not executed again unless one of its inputs/outputs changed. In this case, the task outcome will be ")),o(f,{outcome:"UP-TO-DATE"}),e[37]||(e[37]=n(". "))]),o(y,null,{default:s(()=>e[38]||(e[38]=[n(" This task should not be executed directly. Gradle executes it if the build requires it. ")])),_:1})]),_:1})}}}),gt=x({__name:"install-corepack-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"corepackVersion",type:p.STRING,binding:a.PROPERTY,property:"corepackVersion"}],m=[{name:"corepackModuleDirectory",type:p.DIRECTORY,binding:a.CUSTOM}];return(t,e)=>{const i=b,l=T,d=$,g=E,f=M,k=w,y=I,D=L,O=F;return v(),P(O,{name:"installCorepack","depending-task-names":["installNode"],inputs:u,outputs:m,"custom-environment-variables-supported":""},{title:s(()=>e[0]||(e[0]=[n("Install/upgrade Corepack")])),corepackModuleDirectory:s(()=>[o(i,{name:"nodeInstallDirectory"}),o(l,null,{default:s(()=>e[1]||(e[1]=[n("/node_modules/corepack")])),_:1}),e[2]||(e[2]=n(". "))]),skipConditions:s(()=>[o(i,{name:"corepackVersion"}),e[4]||(e[4]=n(" property is ")),o(l,null,{default:s(()=>e[3]||(e[3]=[n("null")])),_:1}),e[5]||(e[5]=n(". "))]),description:s(()=>[r("p",null,[e[10]||(e[10]=n(" The purpose of this task is to allow replacing the default version of ")),o(d),e[11]||(e[11]=n(" embedded in ")),o(g),e[12]||(e[12]=n(". This may be necessary in case of ")),o(d),e[13]||(e[13]=n(" fails to install the package manager used by the project, or to continuously benefit from the latest improvements and bug fixes. By default, this task is not executed unless property ")),o(i,{name:"corepackVersion"}),e[14]||(e[14]=n(" is defined with a non-")),o(l,null,{default:s(()=>e[6]||(e[6]=[n("null")])),_:1}),e[15]||(e[15]=n(" value. In the latter case, the plugin executes command ")),o(l,null,{default:s(()=>e[7]||(e[7]=[n("npm install -g corepack[@<corepackVersion>]")])),_:1}),e[16]||(e[16]=n(". Apart from a specific version number, if this property is set with the ")),o(l,null,{default:s(()=>e[8]||(e[8]=[n("latest")])),_:1}),e[17]||(e[17]=n(" value, the plugin installs the latest version available. Note that this task will not be executed again and update Corepack automatically if a newer version is released after this task has run once successfully. Since the project may use a package manager that is not ")),o(f),e[18]||(e[18]=n(", the task disables Corepack strict behavior when running ")),o(l,null,{default:s(()=>e[9]||(e[9]=[n("npm")])),_:1}),e[19]||(e[19]=n(" (see environment variable ")),o(d,{path:"#environment-variables",label:"COREPACK_ENABLE_STRICT"}),e[20]||(e[20]=n("). "))]),r("p",null,[e[22]||(e[22]=n(" As the task touches the ")),o(g),e[23]||(e[23]=n(" install directory, please pay attention when using a shared ")),o(g),e[24]||(e[24]=n(" distribution (")),o(i,{name:"nodeDistributionProvided"}),e[25]||(e[25]=n(" is ")),o(l,null,{default:s(()=>e[21]||(e[21]=[n("true")])),_:1}),e[26]||(e[26]=n("), because this task will impact other projects using ")),o(d),e[27]||(e[27]=n(". This may be desirable or not depending on your situation. "))]),r("p",null,[e[29]||(e[29]=n(" The task takes advantage of ")),o(k,{path:"/performance/#incremental_build"},{default:s(()=>e[28]||(e[28]=[n("Gradle incremental build")])),_:1}),e[30]||(e[30]=n(", and is not executed again unless one of its inputs/outputs changed. In this case, the task outcome will be ")),o(y,{outcome:"UP-TO-DATE"}),e[31]||(e[31]=n(". "))]),o(D,null,{default:s(()=>e[32]||(e[32]=[n(" This task should not be executed directly. Gradle executes it if the build requires it. ")])),_:1})]),_:1})}}}),ft=x({__name:"resolve-package-manager-task",setup(R){const u=[{name:"packageJsonFile",type:p.REGULAR_FILE,binding:a.CUSTOM,optionalHint:"Whether this file exists or not changes the behavior of the task, see description hereafter."},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"}],m=[{name:"packageManagerSpecificationFile",type:p.REGULAR_FILE,binding:a.CUSTOM},{name:"packageManagerExecutablePathFile",type:p.REGULAR_FILE,binding:a.CUSTOM}];return(t,e)=>{const i=b,l=T,d=E,g=w,f=I,k=L,y=F;return v(),P(y,{name:"resolvePackageManager","depending-task-names":["installNode"],inputs:u,outputs:m,cacheable:""},{title:s(()=>e[0]||(e[0]=[n("Resolve package manager")])),packageJsonFile:s(()=>[o(i,{name:"packageJsonDirectory"}),o(l,null,{default:s(()=>e[1]||(e[1]=[n("/package.json")])),_:1})]),packageManagerSpecificationFile:s(()=>[o(i,{name:"cacheDirectory"}),o(l,null,{default:s(()=>e[2]||(e[2]=[n("/resolvePackageManager/package-manager-specification.txt")])),_:1})]),packageManagerExecutablePathFile:s(()=>[o(i,{name:"cacheDirectory"}),o(l,null,{default:s(()=>e[3]||(e[3]=[n("/resolvePackageManager/package-manager-executable-path.txt")])),_:1})]),description:s(()=>[r("p",null,[e[5]||(e[5]=n("The behavior of this task depends on the existence of the ")),o(l,null,{default:s(()=>e[4]||(e[4]=[n("package.json")])),_:1}),e[6]||(e[6]=n(" file:"))]),r("ul",null,[r("li",null,[e[12]||(e[12]=n(" If the ")),o(l,null,{default:s(()=>e[7]||(e[7]=[n("package.json")])),_:1}),e[13]||(e[13]=n(" file exists, the task identifies the name and the version of the package manager applicable to the project by parsing the ")),o(d,{path:"/api/packages.html#packagemanager",label:"packageManager"}),e[14]||(e[14]=n(" property. For example, if the ")),o(l,null,{default:s(()=>e[8]||(e[8]=[n("package.json")])),_:1}),e[15]||(e[15]=n(" file contains ")),o(l,null,{default:s(()=>e[9]||(e[9]=[n('"packageManager":Â "npm@10.9.0"')])),_:1}),e[16]||(e[16]=n(", the task resolves ")),o(l,null,{default:s(()=>e[10]||(e[10]=[n("npm")])),_:1}),e[17]||(e[17]=n(" as the name of the package manager, and ")),o(l,null,{default:s(()=>e[11]||(e[11]=[n("10.9.0")])),_:1}),e[18]||(e[18]=n(" as its version. "))]),r("li",null,[e[20]||(e[20]=n(" If the ")),o(l,null,{default:s(()=>e[19]||(e[19]=[n("package.json")])),_:1}),e[21]||(e[21]=n(" file does not exist, the task removes output files to prevent side effects with other tasks provided by the plugin. "))])]),r("p",null,[e[23]||(e[23]=n(" The task takes advantage of ")),o(g,{path:"/performance/#incremental_build"},{default:s(()=>e[22]||(e[22]=[n("Gradle incremental build")])),_:1}),e[24]||(e[24]=n(", and is not executed again unless one of its inputs/outputs changed. In this case, the task outcome will be ")),o(f,{outcome:"UP-TO-DATE"}),e[25]||(e[25]=n(". "))]),o(k,null,{default:s(()=>e[26]||(e[26]=[n(" This task should not be executed directly. Gradle executes it if the build requires it. ")])),_:1})]),_:1})}}}),kt=x({__name:"install-package-manager-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"packageManagerSpecificationFile",type:p.REGULAR_FILE,binding:a.CUSTOM}],m=[{name:"packageManagerExecutableFile",type:p.REGULAR_FILE,binding:a.CUSTOM}];return(t,e)=>{const i=b,l=T,d=C,g=w,f=I,k=L,y=F;return v(),P(y,{name:"installPackageManager","depending-task-names":["installCorepack","resolvePackageManager"],inputs:u,outputs:m,"custom-environment-variables-supported":""},{title:s(()=>e[0]||(e[0]=[n("Install package manager")])),packageManagerSpecificationFile:s(()=>[o(i,{name:"cacheDirectory"}),o(l,null,{default:s(()=>e[1]||(e[1]=[n("/resolvePackageManager/package-manager-specification.txt")])),_:1})]),packageManagerExecutableFile:s(()=>[e[5]||(e[5]=n(" the package manager executable, whose path is provided by file ")),o(i,{name:"cacheDirectory"}),o(l,null,{default:s(()=>e[2]||(e[2]=[n("/resolvePackageManager/package-manager-executable-path.txt")])),_:1}),e[6]||(e[6]=n(" (generally ")),o(i,{name:"nodeInstallDirectory"}),o(l,null,{default:s(()=>e[3]||(e[3]=[n("/[npm|pnpm|yarn].cmd")])),_:1}),e[7]||(e[7]=n(" or ")),o(i,{name:"nodeInstallDirectory"}),o(l,null,{default:s(()=>e[4]||(e[4]=[n("/bin/[npm|pnpm|yarn]")])),_:1}),e[8]||(e[8]=n(" depending on the O/S). "))]),skipConditions:s(()=>[o(i,{name:"packageJsonDirectory"}),o(l,null,{default:s(()=>e[9]||(e[9]=[n("/package.json")])),_:1}),e[10]||(e[10]=n(" file does not exist. "))]),description:s(()=>[r("p",null,[e[12]||(e[12]=n(" The task installs the package manager resolved with task ")),o(d,{name:"resolvePackageManager"}),e[13]||(e[13]=n(", by executing command ")),o(l,null,{default:s(()=>e[11]||(e[11]=[n("corepack enable <package-manager>")])),_:1}),e[14]||(e[14]=n(". "))]),r("p",null,[e[16]||(e[16]=n(" The task takes advantage of ")),o(g,{path:"/performance/#incremental_build"},{default:s(()=>e[15]||(e[15]=[n("Gradle incremental build")])),_:1}),e[17]||(e[17]=n(", and is not executed again unless one of its inputs/outputs changed. Consequently, if the task takes part of a Gradle build, its outcome will be ")),o(f,{outcome:"UP-TO-DATE"}),e[18]||(e[18]=n(". "))]),o(k,null,{default:s(()=>e[19]||(e[19]=[n(" This task should not be executed directly. Gradle executes it if the build requires it. ")])),_:1})]),_:1})}}}),B={class:"card my-3"},H={class:"card-body"},z={class:"card-title"},Z={class:"card-text"},yt=x({__name:"install-frontend-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"script",type:p.STRING,binding:a.PROPERTY,property:"installScript"}];return(m,t)=>{const e=b,i=T,l=E,d=S,g=I,f=C,k=J,y=M,D=N,O=V,G=q,A=j,U=F;return v(),P(U,{name:"installFrontend","depending-task-names":["installPackageManager"],inputs:u,"custom-environment-variables-supported":""},{title:s(()=>t[0]||(t[0]=[n("Install frontend dependencies")])),skipConditions:s(()=>[o(e,{name:"packageJsonDirectory"}),o(i,null,{default:s(()=>t[1]||(t[1]=[n("/package.json")])),_:1}),t[2]||(t[2]=n(" file does not exist. "))]),description:s(()=>[r("p",null,[t[7]||(t[7]=n(" Depending on the package manager, this task executes either command ")),o(i,null,{default:s(()=>t[3]||(t[3]=[n("npm install")])),_:1}),t[8]||(t[8]=n(", or command ")),o(i,null,{default:s(()=>t[4]||(t[4]=[n("pnpm install")])),_:1}),t[9]||(t[9]=n(", or command ")),o(i,null,{default:s(()=>t[5]||(t[5]=[n("yarn install")])),_:1}),t[10]||(t[10]=n(", by default. Consequently, the command shall install project dependencies according to the algorithm followed by each package manager (see hereafter). Optionally, this command may be customized with the ")),o(e,{name:"installScript"}),t[11]||(t[11]=n(" property (e.g. to run a ")),o(i,null,{default:s(()=>t[6]||(t[6]=[n("npm ci")])),_:1}),t[12]||(t[12]=n(" command instead). On a developer workstation, executing this task is a good starting point to setup a workspace for development as it will install the ")),o(l),t[13]||(t[13]=n(" distribution (if not provided) as well as dependencies. "))]),r("div",B,[r("div",H,[r("h5",z,[t[15]||(t[15]=n(" About ")),o(d,{path:"/current/userguide/incremental_build.html"},{default:s(()=>t[14]||(t[14]=[n("incremental build")])),_:1}),t[16]||(t[16]=n(" and up-to-date checks "))]),r("div",Z,[r("p",null,[t[21]||(t[21]=n(" If you execute this task several times in a row, you may notice the ")),o(i,null,{default:s(()=>t[17]||(t[17]=[n("npm")])),_:1}),t[22]||(t[22]=n("/")),o(i,null,{default:s(()=>t[18]||(t[18]=[n("pnpm")])),_:1}),t[23]||(t[23]=n("/")),o(i,null,{default:s(()=>t[19]||(t[19]=[n("yarn")])),_:1}),t[24]||(t[24]=n(" command is always executed: Gradle does not reuse task outputs based on a previous execution with the ")),o(g,{outcome:"SUCCESS"}),t[25]||(t[25]=n(" outcome. This is the expected behaviour ")),t[26]||(t[26]=r("span",{class:"font-italic"},"by default",-1)),t[27]||(t[27]=n(" because the task does not declare any relevant input(s) and output(s) Gradle could track to know the task is already ")),o(g,{outcome:"UP-TO-DATE"}),t[28]||(t[28]=n(" (e.g. unlike the ")),o(f,{name:"installNode"}),t[29]||(t[29]=n(" task). Resolving these inputs/outputs is a bit complex, since it depends on the package manager, the value of the ")),o(e,{name:"installScript"}),t[30]||(t[30]=n(" property, and the files present in the project. That's why incremental build for this task is not available out-of-the-box by now. However, some ")),o(k,{path:"/tree/main/examples"},{default:s(()=>t[20]||(t[20]=[n("examples")])),_:1}),t[31]||(t[31]=n(" provide guidelines to customize this task and limit executions under certain circumstances. Notes hereafter provide also some unofficial ideas: "))]),r("ul",null,[r("li",null,[o(y),t[43]||(t[43]=n(": inputs may be one or more of files ")),o(i,null,{default:s(()=>t[32]||(t[32]=[n("package.json")])),_:1}),t[44]||(t[44]=n(", ")),o(i,null,{default:s(()=>t[33]||(t[33]=[n("npm-shrinkwrap.json")])),_:1}),t[45]||(t[45]=n(", ")),o(i,null,{default:s(()=>t[34]||(t[34]=[n("package-lock.json")])),_:1}),t[46]||(t[46]=n(", ")),o(i,null,{default:s(()=>t[35]||(t[35]=[n("yarn.lock")])),_:1}),t[47]||(t[47]=n(", while outputs may be the ")),o(i,null,{default:s(()=>t[36]||(t[36]=[n("node_modules")])),_:1}),t[48]||(t[48]=n(" directory and the ")),o(i,null,{default:s(()=>t[37]||(t[37]=[n("package-lock.json")])),_:1}),t[49]||(t[49]=n(" file (see ")),o(D,{path:"/cli/v10/commands/npm-install"},{default:s(()=>t[38]||(t[38]=[n("npm install")])),_:1}),t[50]||(t[50]=n("). If the ")),o(e,{name:"installScript"}),t[51]||(t[51]=n(" property is set with ")),o(i,null,{default:s(()=>t[39]||(t[39]=[n("ci")])),_:1}),t[52]||(t[52]=n(", file ")),o(i,null,{default:s(()=>t[40]||(t[40]=[n("package-lock.json")])),_:1}),t[53]||(t[53]=n(" or file ")),o(i,null,{default:s(()=>t[41]||(t[41]=[n("npm-shrinkwrap.json")])),_:1}),t[54]||(t[54]=n(" may be the only possible input file, if one or the other exists, and the ")),o(i,null,{default:s(()=>t[42]||(t[42]=[n("node_modules")])),_:1}),t[55]||(t[55]=n(" directory the only output. "))]),r("li",null,[o(O),t[60]||(t[60]=n(": inputs may be one or more of files ")),o(i,null,{default:s(()=>t[56]||(t[56]=[n("package.json")])),_:1}),t[61]||(t[61]=n(", ")),o(i,null,{default:s(()=>t[57]||(t[57]=[n("pnpm-lock.yaml")])),_:1}),t[62]||(t[62]=n(", while outputs may be the ")),o(i,null,{default:s(()=>t[58]||(t[58]=[n("node_modules")])),_:1}),t[63]||(t[63]=n(" directory and the ")),o(i,null,{default:s(()=>t[59]||(t[59]=[n("pnpm-lock.yaml")])),_:1}),t[64]||(t[64]=n(" file. "))]),r("li",null,[o(G),t[71]||(t[71]=n(": inputs may be one or more of files ")),o(i,null,{default:s(()=>t[65]||(t[65]=[n("package.json")])),_:1}),t[72]||(t[72]=n(", ")),o(i,null,{default:s(()=>t[66]||(t[66]=[n("yarn.lock")])),_:1}),t[73]||(t[73]=n(", while outputs may be the ")),o(i,null,{default:s(()=>t[67]||(t[67]=[n("node_modules")])),_:1}),t[74]||(t[74]=n(" directory, or the ")),o(i,null,{default:s(()=>t[68]||(t[68]=[n(".pnp.cjs")])),_:1}),t[75]||(t[75]=n(" file and the ")),o(i,null,{default:s(()=>t[69]||(t[69]=[n(".yarn/cache")])),_:1}),t[76]||(t[76]=n(" directory (")),o(G,{label:"Zero-installs",title:"Zero-Install feature"}),t[77]||(t[77]=n("), and the ")),o(i,null,{default:s(()=>t[70]||(t[70]=[n("yarn.lock")])),_:1}),t[78]||(t[78]=n(" file. "))])]),r("p",null,[t[80]||(t[80]=n(" If you are about to tweak this task to declare additional inputs and outputs, take a look at these ")),o(A,{path:`${m.$config.public.paths.tasks}#builtin-tasks-customization`},{default:s(()=>t[79]||(t[79]=[n("recommendations")])),_:1},8,["path"]),t[81]||(t[81]=n(". "))])])])])]),_:1})}}}),bt=x({__name:"clean-frontend-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"script",type:p.STRING,binding:a.PROPERTY,property:"cleanScript"}];return(m,t)=>{const e=b,i=T,l=S,d=F;return v(),P(d,{name:"cleanFrontend","depending-task-names":["installFrontend"],inputs:u,"custom-environment-variables-supported":""},{title:s(()=>t[0]||(t[0]=[n("Clean frontend artifacts")])),skipConditions:s(()=>[o(e,{name:"packageJsonDirectory"}),o(i,null,{default:s(()=>t[1]||(t[1]=[n("/package.json")])),_:1}),t[3]||(t[3]=n(" file does not exist, or ")),o(e,{name:"cleanScript"}),t[4]||(t[4]=n(" is ")),o(i,null,{default:s(()=>t[2]||(t[2]=[n("null")])),_:1}),t[5]||(t[5]=n(". "))]),description:s(()=>[r("p",null,[t[12]||(t[12]=n(" This task does nothing by default, considering frontend artifacts (minimified Javascript, CSS, HTML files...) are generated in the ")),o(i,null,{default:s(()=>t[6]||(t[6]=[n("${project.buildDir}")])),_:1}),t[13]||(t[13]=n(" directory. If it is not the case, this task may be useful to clean the relevant directory. A clean script shall be defined in the ")),o(i,null,{default:s(()=>t[7]||(t[7]=[n("package.json")])),_:1}),t[14]||(t[14]=n(" file, and the ")),o(e,{name:"cleanScript"}),t[15]||(t[15]=n(" property shall be set with the corresponding ")),o(i,null,{default:s(()=>t[8]||(t[8]=[n("npm")])),_:1}),t[16]||(t[16]=n("/")),o(i,null,{default:s(()=>t[9]||(t[9]=[n("pnpm")])),_:1}),t[17]||(t[17]=n("/")),o(i,null,{default:s(()=>t[10]||(t[10]=[n("yarn")])),_:1}),t[18]||(t[18]=n(" command. Apart from direct execution, the task is also executed when the Gradle lifecycle ")),o(l,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:s(()=>t[11]||(t[11]=[n("clean")])),_:1}),t[19]||(t[19]=n(" task is executed. "))])]),_:1})}}}),X={class:"card my-3"},K={class:"card-body"},W={class:"card-title"},Q={class:"card-text"},Tt=x({__name:"assemble-frontend-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"script",type:p.STRING,binding:a.PROPERTY,property:"assembleScript"}];return(m,t)=>{const e=b,i=T,l=S,d=I,g=C,f=j,k=F;return v(),P(k,{name:"assembleFrontend","depending-task-names":["installFrontend"],inputs:u,"custom-environment-variables-supported":""},{title:s(()=>t[0]||(t[0]=[n("Assemble frontend artifacts")])),skipConditions:s(()=>[o(e,{name:"packageJsonDirectory"}),o(i,null,{default:s(()=>t[1]||(t[1]=[n("/package.json")])),_:1}),t[3]||(t[3]=n(" file does not exist, or ")),o(e,{name:"assembleScript"}),t[4]||(t[4]=n(" is ")),o(i,null,{default:s(()=>t[2]||(t[2]=[n("null")])),_:1}),t[5]||(t[5]=n(". "))]),description:s(()=>[t[26]||(t[26]=n(" This task allows to execute a build script as part of a Gradle build. The build script shall be defined in the ")),o(i,null,{default:s(()=>t[6]||(t[6]=[n("package.json")])),_:1}),t[27]||(t[27]=n(" file, and the ")),o(e,{name:"assembleScript"}),t[28]||(t[28]=n(" property shall be set with the corresponding ")),o(i,null,{default:s(()=>t[7]||(t[7]=[n("npm")])),_:1}),t[29]||(t[29]=n("/")),o(i,null,{default:s(()=>t[8]||(t[8]=[n("pnpm")])),_:1}),t[30]||(t[30]=n("/")),o(i,null,{default:s(()=>t[9]||(t[9]=[n("yarn")])),_:1}),t[31]||(t[31]=n(" command. Apart from direct execution, the task is also executed when the Gradle lifecycle ")),o(l,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:s(()=>t[10]||(t[10]=[n("assemble")])),_:1}),t[32]||(t[32]=n(" task is executed. ")),r("div",X,[r("div",K,[r("h5",W,[t[12]||(t[12]=n(" About ")),o(l,{path:"/current/userguide/incremental_build.html"},{default:s(()=>t[11]||(t[11]=[n("incremental build")])),_:1}),t[13]||(t[13]=n(" and up-to-date checks "))]),r("p",Q,[t[18]||(t[18]=n(" If you execute this task several times in a row, you may notice the ")),o(i,null,{default:s(()=>t[14]||(t[14]=[n("npm")])),_:1}),t[19]||(t[19]=n("/")),o(i,null,{default:s(()=>t[15]||(t[15]=[n("pnpm")])),_:1}),t[20]||(t[20]=n("/")),o(i,null,{default:s(()=>t[16]||(t[16]=[n("yarn")])),_:1}),t[21]||(t[21]=n(" command is always executed: Gradle does not skip the task based on a previous execution with the ")),o(d,{outcome:"SUCCESS"}),t[22]||(t[22]=n(" outcome. This is the expected behaviour because the task does not declare any input/output Gradle could track, to know the task is already ")),o(d,{outcome:"UP-TO-DATE"}),t[23]||(t[23]=n(" (e.g. unlike task ")),o(g,{name:"installNode"}),t[24]||(t[24]=n("). The task provides the ability to plug the developer's own Javascript build process to Gradle, and nothing more. Every Javascript build process is unique: it depends on the project, the languages involved (e.g. TypeScript, JSX, ECMA script, SASS, SCSS...), the directory layout, the build utilities (Webpack...), etc., chosen by the team. Moreover, some build utilities are already able to build artifacts incrementally. The plugin does not duplicate this logic. If you are about to tweak this task, take a look at these ")),o(f,{path:`${m.$config.public.paths.tasks}#builtin-tasks-customization`},{default:s(()=>t[17]||(t[17]=[n("recommendations")])),_:1},8,["path"]),t[25]||(t[25]=n(". "))])])])]),_:1})}}}),Ft=x({__name:"check-frontend-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"script",type:p.STRING,binding:a.PROPERTY,property:"checkScript"}];return(m,t)=>{const e=b,i=T,l=S,d=F;return v(),P(d,{name:"checkFrontend","depending-task-names":["installFrontend"],inputs:u,"custom-environment-variables-supported":""},{title:s(()=>t[0]||(t[0]=[n("Check frontend application")])),skipConditions:s(()=>[o(e,{name:"packageJsonDirectory"}),o(i,null,{default:s(()=>t[1]||(t[1]=[n("/package.json")])),_:1}),t[3]||(t[3]=n(" file does not exist, or ")),o(e,{name:"checkScript"}),t[4]||(t[4]=n(" is ")),o(i,null,{default:s(()=>t[2]||(t[2]=[n("null")])),_:1}),t[5]||(t[5]=n(". "))]),description:s(()=>[r("p",null,[t[11]||(t[11]=n(" This task may be used to integrate a check script into a Gradle build. The check script shall be defined in the ")),o(i,null,{default:s(()=>t[6]||(t[6]=[n("package.json")])),_:1}),t[12]||(t[12]=n(" file, and the ")),o(e,{name:"checkScript"}),t[13]||(t[13]=n(" property shall be set with the corresponding ")),o(i,null,{default:s(()=>t[7]||(t[7]=[n("npm")])),_:1}),t[14]||(t[14]=n("/")),o(i,null,{default:s(()=>t[8]||(t[8]=[n("pnpm")])),_:1}),t[15]||(t[15]=n("/")),o(i,null,{default:s(()=>t[9]||(t[9]=[n("yarn")])),_:1}),t[16]||(t[16]=n(" command. A typical check script may lint source files, execute tests, and/or perform additional analysis actions. Apart from direct execution, the task is also executed when the Gradle lifecycle ")),o(l,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:s(()=>t[10]||(t[10]=[n("check")])),_:1}),t[17]||(t[17]=n(" task is executed. "))])]),_:1})}}}),xt=x({__name:"publish-frontend-task",setup(R){const u=[{name:"packageJsonDirectory",type:p.FILE,binding:a.PROPERTY,property:"packageJsonDirectory"},{name:"nodeInstallDirectory",type:p.FILE,binding:a.PROPERTY,property:"nodeInstallDirectory"},{name:"script",type:p.STRING,binding:a.PROPERTY,property:"publishScript"}];return(m,t)=>{const e=b,i=T,l=F;return v(),P(l,{name:"publishFrontend","depending-task-names":["assembleFrontend"],inputs:u,"custom-environment-variables-supported":""},{title:s(()=>t[0]||(t[0]=[n("Publish frontend artifacts")])),skipConditions:s(()=>[o(e,{name:"packageJsonDirectory"}),o(i,null,{default:s(()=>t[1]||(t[1]=[n("/package.json")])),_:1}),t[4]||(t[4]=n(" file does not exist, or ")),o(e,{name:"assembleScript"}),t[5]||(t[5]=n(" is ")),o(i,null,{default:s(()=>t[2]||(t[2]=[n("null")])),_:1}),t[6]||(t[6]=n(", or ")),o(e,{name:"publishScript"}),t[7]||(t[7]=n(" is ")),o(i,null,{default:s(()=>t[3]||(t[3]=[n("null")])),_:1}),t[8]||(t[8]=n(". "))]),description:s(()=>[r("p",null,[t[14]||(t[14]=n(" This task may be used to integrate a publish script into a Gradle build. The publish script shall be defined in the ")),o(i,null,{default:s(()=>t[9]||(t[9]=[n("package.json")])),_:1}),t[15]||(t[15]=n(" file, and the ")),o(e,{name:"publishScript"}),t[16]||(t[16]=n(" property shall be set with the corresponding ")),o(i,null,{default:s(()=>t[10]||(t[10]=[n("npm")])),_:1}),t[17]||(t[17]=n("/")),o(i,null,{default:s(()=>t[11]||(t[11]=[n("pnpm")])),_:1}),t[18]||(t[18]=n("/")),o(i,null,{default:s(()=>t[12]||(t[12]=[n("yarn")])),_:1}),t[19]||(t[19]=n(" command. Apart from direct execution, the task is also executed when the Gradle ")),o(i,null,{default:s(()=>t[13]||(t[13]=[n("publish")])),_:1}),t[20]||(t[20]=n(" task is executed. "))])]),_:1})}}});export{mt as _,gt as a,ft as b,kt as c,yt as d,bt as e,Tt as f,Ft as g,xt as h};
