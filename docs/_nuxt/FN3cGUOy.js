import{_ as u}from"./zck6Z6fF.js";import{_ as f}from"./BkGJl2ZQ.js";import{_ as h}from"./BHt_xBA0.js";import{b as _}from"./kHwnZ90X.js";import{_ as c}from"./DlAUqK2U.js";import{o as i,f as d,w as n,d as e,b as t,a}from"./0eoLPSdn.js";import{_ as g}from"./BFqTcm4f.js";import{_ as y}from"./DysKOmB8.js";const b={};function k(p,m){const o=u,l=f,r=h,s=_;return i(),d(s,null,{question:n(()=>[e(" How to use "),t(o,null,{default:n(()=>[e("node")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("corepack")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("pnpm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("yarn")]),_:1}),e(" executables apart from Gradle when the "),t(l),e(" distribution is downloaded by the plugin? ")]),answer:n(()=>[a("ul",null,[a("li",null,[e(" Create a "),t(o,null,{default:n(()=>[e("NODEJS_HOME")]),_:1}),e(" environment variable (or a name of your choice) containing the real path set in the "),t(r,{name:"nodeInstallDirectory"}),e(" property. ")]),a("li",null,[e(" Add the directory containing executables to the "),t(o,null,{default:n(()=>[e("PATH")]),_:1}),e(" environment variable: "),a("ul",null,[a("li",null,[e(" On Unix-like O/S, add the "),t(o,null,{default:n(()=>[e("$NODEJS_HOME/bin")]),_:1}),e(" path. ")]),a("li",null,[e("On Windows O/S, add "),t(o,null,{default:n(()=>[e("%NODEJS_HOME%")]),_:1}),e(" path.")])])])])]),_:1})}const H=c(b,[["render",k]]),x={};function w(p,m){const o=u,l=g,r=y,s=_;return i(),d(s,null,{question:n(()=>[e(" What's the purpose of the "),t(o,null,{default:n(()=>[e(".frontend-gradle-plugin")]),_:1}),e(" directory generated in each project? ")]),answer:n(()=>[e(" The plugin uses this directory to store some task outputs as files, so as Gradle can perform "),t(l,{path:"/current/userguide/incremental_build.html"},{default:n(()=>[e("up-to-date checks")]),_:1}),e(". It allows to skip some task execution and optimize build time when inputs did not change, by reusing the already computed outputs. Generally, the "),t(o,null,{default:n(()=>[e("build")]),_:1}),e(" directory of the project is used for such goal, but the plugin cannot rely on this directory because it is removed when Gradle "),t(o,null,{default:n(()=>[e("clean")]),_:1}),e(" task is executed. This would remove mandatory outputs for plugin task "),t(r,{name:"cleanFrontend"}),e(". ")]),_:1})}const S=c(x,[["render",w]]);export{H as _,S as a};
