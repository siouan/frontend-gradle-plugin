import{_ as w}from"./BkGJl2ZQ.js";import{_ as g}from"./BHt_xBA0.js";import{_ as p,a as v,b as N}from"./zck6Z6fF.js";import{a as $}from"./COc4Puty.js";import{_ as T,a as C,b as u}from"./B6j9K0o-.js";import{_ as j}from"./CtBl-4bT.js";import{_}from"./DlAUqK2U.js";import{o as m,f as h,w as n,d as e,b as t,a as i}from"./0eoLPSdn.js";import{_ as y}from"./DysKOmB8.js";import{_ as b}from"./BFqTcm4f.js";import{_ as A}from"./BSZXaiZV.js";import{_ as P}from"./DQimxJDu.js";import{_ as S}from"./C-3WmzZG.js";import{_ as G}from"./Bag9INXo.js";const R={};function O(c,f){const o=w,a=g,s=p,l=$,r=T,d=C,k=j,x=u;return m(),h(x,{name:"installNode"},{title:n(()=>[e("Install "),t(o)]),description:n(()=>[i("p",null,[e(" The task downloads a "),t(o),e(" distribution, verifies its integrity, and installs it in the directory pointed by the "),t(a,{name:"nodeInstallDirectory"}),e(" property. The URL used to download the distribution is resolved using the "),t(a,{name:"nodeDistributionUrlRoot"}),e(" property and the "),t(a,{name:"nodeDistributionUrlPathPattern"}),e(" property. Checking the distribution integrity consists of downloading a file providing the distribution shasum. This file is expected to be in the same remote web directory than the distribution archive. For example, if the distribution is located at "),t(s,null,{default:n(()=>[e("https://nodejs.org/dist/vX.Y.Z/node-vX.Y.Z-win-x64.zip")]),_:1}),e(", the plugin attempts to download the shasum file located at "),t(s,null,{default:n(()=>[e("https://nodejs.org/dist/vX.Y.Z/SHASUMS256.txt")]),_:1}),e(". By default, the plugin relies on the VM "),t(l,null,{default:n(()=>[e("network properties")]),_:1}),e(" to know if a proxy server shall be used when downloading the distribution and the shasum. A custom proxy server may also be used by defining "),t(a,{name:"httpsProxyHost"}),e(" property (respectively "),t(a,{name:"httpProxyHost"}),e(" property) if the "),t(a,{name:"nodeDistributionUrlRoot"}),e(" property uses the "),t(s,null,{default:n(()=>[e("https")]),_:1}),e(" protocol (resp. uses the "),t(s,null,{default:n(()=>[e("http")]),_:1}),e(" protocol). ")]),i("p",null,[e(" If a "),t(o),e(" distribution is already installed in the system - either as a global installation or as an installation performed by another Gradle (sub-)project - and shall be used instead of a downloaded distribution, take a look at the "),t(a,{name:"nodeDistributionProvided"}),e(" property instead: when "),t(s,null,{default:n(()=>[e("true")]),_:1}),e(", this task is ignored if invoked during a Gradle build, and its outcome will always be "),t(r,{outcome:"SKIPPED"}),e(". ")]),i("p",null,[e(" The task takes advantage of "),t(d,{path:"/performance/#incremental_build"},{default:n(()=>[e("Gradle incremental build")]),_:1}),e(", and is not executed again unless one of its inputs/outputs changed. Consequently, if the task takes part of a Gradle build, its outcome will be "),t(r,{outcome:"UP-TO-DATE"}),e(". ")]),t(k,null,{default:n(()=>[e(" This task should not be executed directly. Gradle executes it if the build requires it. ")]),_:1})]),_:1})}const xe=_(R,[["render",O]]),D={},q={class:"card my-3"},I={class:"card-body"},E={class:"card-title"},U={class:"card-text"},J={class:"text-muted small"};function Y(c,f){const o=g,a=p,s=y,l=b,r=T,d=A,k=P,x=v,F=N,L=u;return m(),h(L,{name:"installFrontend"},{title:n(()=>[e("Install frontend dependencies")]),description:n(()=>[i("p",null,[e(" Depending on the value of the "),t(o,{name:"yarnEnabled"}),e(" property, this task issues either a "),t(a,null,{default:n(()=>[e("npm install")]),_:1}),e(" command or a "),t(a,null,{default:n(()=>[e("yarn install")]),_:1}),e(" command, by default. Consequently, the command shall install/update dependencies, and perform any additional actions as described in the "),t(a,null,{default:n(()=>[e("package.json")]),_:1}),e(" file located in the directory pointed by the "),t(o,{name:"packageJsonDirectory"}),e(" property. Optionally, this command may be customized with the "),t(o,{name:"installScript"}),e(" property (e.g. to run a "),t(a,null,{default:n(()=>[e("npm ci")]),_:1}),e(" command instead). This task depends on the "),t(s,{name:"installNode"}),e(" task, and optionally on the "),t(s,{name:"installYarn"}),e(" task if the "),t(o,{name:"yarnEnabled"}),e(" property is "),t(a,null,{default:n(()=>[e("true")]),_:1}),e(". ")]),i("div",q,[i("div",I,[i("h5",E,[e(" About "),t(l,{path:"/current/userguide/incremental_build.html"},{default:n(()=>[e("incremental build")]),_:1}),e(" and up-to-date checks ")]),i("p",U,[e(" If you execute this task several times in a row, you may notice the "),t(a,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(a,null,{default:n(()=>[e("yarn")]),_:1}),e(" command is always executed: Gradle does not skip the task based on a previous execution with the "),t(r,{outcome:"SUCCESS"}),e(" outcome. This is the expected behaviour because the task does not declare any input/output Gradle could track, to know the task is already "),t(r,{outcome:"UP-TO-DATE"}),e(" - unlike the "),t(s,{name:"installNode"}),e(" and "),t(s,{name:"installYarn"}),e(" tasks. Both "),t(d),e(" and "),t(k),e(" have their own strategy to limit overhead when dependencies are already up to date. The plugin does not duplicate this logic, considering it is the business of each package manager, and it would hardly perform as well. If you are tempted to tweak the task so as its execution is skipped under certain circumstances (e.g. declaring the large "),t(a,null,{default:n(()=>[e("nodes_modules")]),_:1}),e(" directory as an output), you would move this logic in Gradle. Gradle cannot do magic with large directories, and would have to track each file individually to determine whether the task should be executed or skipped. The question may be: is it worth moving the overhead to Gradle to skip task execution - maybe, or accepting the one occuring when "),t(a,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(a,null,{default:n(()=>[e("yarn")]),_:1}),e(" is executed again? If you are about to tweak this task, take a look at these "),t(x,{path:"#tweaking-tasks"},{default:n(()=>[e("recommendations")]),_:1}),e(". ")]),i("div",J,[e(" Some related discussions in Gradle forums: ["),t(F,{href:"https://discuss.gradle.org/t/project-level-build-cache-for-javascript-and-yarn-projects/24134",title:"A discussion in Gradle forums"},{default:n(()=>[e("1")]),_:1}),e("] ["),t(F,{href:"https://discuss.gradle.org/t/gradle-having-problems-with-large-folders-as-task-inputs-outputs/34775",title:"A discussion in Gradle forums"},{default:n(()=>[e("2")]),_:1}),e("] ["),t(F,{href:"https://discuss.gradle.org/t/incremental-task-false-up-to-date-result/24619",title:"A discussion in Gradle forums"},{default:n(()=>[e("3")]),_:1}),e("] ")])])])]),_:1})}const Fe=_(D,[["render",Y]]),V={};function B(c,f){const o=p,a=g,s=y,l=b,r=u;return m(),h(r,{name:"cleanFrontend"},{title:n(()=>[e("Clean frontend artifacts")]),description:n(()=>[i("p",null,[e(" This task does nothing by default, considering frontend artifacts (minimified Javascript, CSS, HTML files...) are generated in the "),t(o,null,{default:n(()=>[e("${project.buildDir}")]),_:1}),e(" directory. If it is not the case, this task may be useful to clean the relevant directory. A clean script shall be defined in the "),t(o,null,{default:n(()=>[e("package.json")]),_:1}),e(" file, and the "),t(a,{name:"cleanScript"}),e(" property shall be set with the corresponding "),t(o,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("yarn")]),_:1}),e(" command. This task depends on the "),t(s,{name:"installFrontend"}),e(" task, and is skipped if the "),t(a,{name:"cleanScript"}),e(" property is "),t(o,null,{default:n(()=>[e("null")]),_:1}),e(". Apart from direct execution, the task is also executed when the Gradle lifecycle "),t(l,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:n(()=>[e("clean")]),_:1}),e(" task is executed. ")])]),_:1})}const we=_(V,[["render",B]]),M={},H={class:"card my-3"},X={class:"card-body"},Z=i("h5",{class:"card-title"},"About task execution and up-to-date checks",-1),z={class:"card-text"};function W(c,f){const o=p,a=g,s=y,l=b,r=T,d=v,k=u;return m(),h(k,{name:"assembleFrontend"},{title:n(()=>[e("Assemble frontend artifacts")]),description:n(()=>[e(" This task allows to execute a build script as part of a Gradle build. The build script shall be defined in the "),t(o,null,{default:n(()=>[e("package.json")]),_:1}),e(" file, and the "),t(a,{name:"assembleScript"}),e(" property shall be set with the corresponding "),t(o,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("yarn")]),_:1}),e(" command. This task depends on the "),t(s,{name:"installFrontend"}),e(" task, and is skipped if the "),t(a,{name:"assembleScript"}),e(" property is "),t(o,null,{default:n(()=>[e("null")]),_:1}),e(". Apart from direct execution, the task is also executed when the Gradle lifecycle "),t(l,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:n(()=>[e("assemble")]),_:1}),e(" task is executed. "),i("div",H,[i("div",X,[Z,i("p",z,[e(" If you execute this task several times in a row, you may notice the "),t(o,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("pnpm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("yarn")]),_:1}),e(" command is always executed: Gradle does not skip the task based on a previous execution with the "),t(r,{outcome:"SUCCESS"}),e(" outcome. This is the expected behaviour because the task does not declare any input/output Gradle could track, to know the task is already "),t(r,{outcome:"UP-TO-DATE"}),e(" (e.g. unlike tasks "),t(s,{name:"installNode"}),e(" and "),t(s,{name:"installYarn"}),e("). The task provides the ability to plug the developer's own Javascript build process to Gradle, and nothing more. Every Javascript build process is unique: it depends on the project, the languages involved (e.g. TypeScript, JSX, ECMA script, SASS, SCSS...), the directory layout, the build utilities (Webpack...), etc., chosen by the team. Moreover, some build utilities are already able to build artifacts incrementally. The plugin does not duplicate this logic. If you are about to tweak this task, take a look at these "),t(d,{path:`${c.$config.public.paths.tasks}#tweaking-tasks`},{default:n(()=>[e("recommendations")]),_:1},8,["path"]),e(". ")])])])]),_:1})}const Te=_(M,[["render",W]]),K={};function Q(c,f){const o=p,a=g,s=y,l=b,r=u;return m(),h(r,{name:"checkFrontend"},{title:n(()=>[e("Check frontend application")]),description:n(()=>[i("p",null,[e(" This task may be used to integrate a check script into a Gradle build. The check script shall be defined in the "),t(o,null,{default:n(()=>[e("package.json")]),_:1}),e(" file, and the "),t(a,{name:"checkScript"}),e(" property shall be set with the corresponding "),t(o,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("yarn")]),_:1}),e(" command. A typical check script may lint source files, execute tests, and/or perform additional analysis actions. This task depends on the "),t(s,{name:"installFrontend"}),e(" task, and is skipped if the "),t(a,{name:"checkScript"}),e(" property is "),t(o,null,{default:n(()=>[e("null")]),_:1}),e(". Apart from direct execution, the task is also executed when the Gradle lifecycle "),t(l,{path:"/current/userguide/base_plugin.html#sec:base_tasks"},{default:n(()=>[e("check")]),_:1}),e(" task is executed. ")])]),_:1})}const ve=_(K,[["render",Q]]),ee={};function te(c,f){const o=p,a=g,s=y,l=u;return m(),h(l,{name:"publishFrontend"},{title:n(()=>[e("Publish frontend artifacts")]),description:n(()=>[i("p",null,[e(" This task may be used to integrate a publish script into a Gradle build. The publish script shall be defined in the "),t(o,null,{default:n(()=>[e("package.json")]),_:1}),e(" file, and the "),t(a,{name:"publishScript"}),e(" property shall be set with the corresponding "),t(o,null,{default:n(()=>[e("npm")]),_:1}),e("/"),t(o,null,{default:n(()=>[e("yarn")]),_:1}),e(" command. This task depends on the "),t(s,{name:"assembleFrontend"}),e(" task, and is skipped either if the "),t(a,{name:"assembleScript"}),e(" property is "),t(o,null,{default:n(()=>[e("null")]),_:1}),e(", or if the "),t(a,{name:"publishScript"}),e(" property is "),t(o,null,{default:n(()=>[e("null")]),_:1}),e(". Apart from direct execution, the task is also executed when the Gradle "),t(o,null,{default:n(()=>[e("publish")]),_:1}),e(" task is executed. ")])]),_:1})}const Se=_(ee,[["render",te]]),ne={};function oe(c,f){const o=p,a=w,s=y,l=S,r=G,d=u;return m(),h(d,{name:"RunNode",type:""},{title:n(()=>[e("Run a custom command with "),t(o,null,{default:n(()=>[e("node")]),_:1})]),description:n(()=>[i("p",null,[e(" The plugin provides task type "),t(o,null,{default:n(()=>[e("org.siouan.frontendgradleplugin.infrastructure.gradle.RunNode")]),_:1}),e(" that allows creating a custom task to run a JS script. The "),t(o,null,{default:n(()=>[e("script")]),_:1}),e(" property must be set with the corresponding command. Then, choose whether "),t(a),e(" only is required, or if additional dependencies located in the "),t(o,null,{default:n(()=>[e("package.json")]),_:1}),e(" file should be installed: make the task either depends on "),t(s,{name:"installNode"}),e(" task or on "),t(s,{name:"installFrontend"}),e(" task. The code hereafter shows the configuration required to run a JS script: ")]),t(r,{id:"run-node-example"},{groovy:n(()=>[i("pre",null,[t(o,null,{default:n(()=>[e(`import org.siouan.frontendgradleplugin.infrastructure.gradle.RunNode
tasks.register('myScript', RunNode) {
    `),t(l,null,{default:n(()=>[e(`// dependsOn tasks.named('installNode')
    // dependsOn tasks.named('installFrontend')`)]),_:1}),e(`
    script = 'my-script.js'
}`)]),_:1})])]),kotlin:n(()=>[i("pre",null,[t(o,null,{default:n(()=>[e(`import org.siouan.frontendgradleplugin.infrastructure.gradle.RunNode
tasks.register<RunNode>("myScript") {
    `),t(l,null,{default:n(()=>[e(`// dependsOn(tasks.named("installNode"))
    // dependsOn(tasks.named("installFrontend"))`)]),_:1}),e(`
    script.set("my-script.js")
}`)]),_:1})])]),_:1})]),_:1})}const Ge=_(ne,[["render",oe]]),ae={},se=i("blockquote",{class:"blockquote"}," Requires Node.js 8.2.0+ on Unix-like O/S, Node.js 8.5.0+ on Windows O/S ",-1);function ie(c,f){const o=p,a=g,s=w,l=y,r=S,d=G,k=u;return m(),h(k,{name:"RunNpx",type:!0},{title:n(()=>[e("Run a custom command with "),t(o,null,{default:n(()=>[e("npx")]),_:1})]),description:n(()=>[se,i("p",null,[e(" The plugin provides the task type "),t(o,null,{default:n(()=>[e("org.siouan.frontendgradleplugin.infrastructure.gradle.RunNpx")]),_:1}),e(" that allows creating a custom task to run a "),t(o,null,{default:n(()=>[e("npx")]),_:1}),e(" command. The "),t(o,null,{default:n(()=>[e("script")]),_:1}),e(" property must be set with the corresponding command. The task will fail if the "),t(a,{name:"yarnEnabled"}),e(" property is "),t(o,null,{default:n(()=>[e("true")]),_:1}),e(", to prevent unpredictable behaviors with mixed installation of dependencies. Then, choose whether "),t(s),e(" only is required, or if additional dependencies located in the "),t(o,null,{default:n(()=>[e("package.json")]),_:1}),e(" file should be installed: make the task either depends on "),t(l,{name:"installNode"}),e(" task or on "),t(l,{name:"installFrontend"}),e(" task. The code hereafter shows the configuration required to output the version of "),t(o,null,{default:n(()=>[e("npx")]),_:1}),e(": ")]),t(d,{id:"run-npx-example",class:"my-3"},{groovy:n(()=>[i("pre",null,[t(o,null,{default:n(()=>[e(`import org.siouan.frontendgradleplugin.infrastructure.gradle.RunNpx
tasks.register('npxVersion', RunNpx) {
    `),t(r,null,{default:n(()=>[e(`// dependsOn tasks.named('installNode')
    // dependsOn tasks.named('installFrontend')`)]),_:1}),e(`
    script = '--version'
}`)]),_:1})])]),kotlin:n(()=>[i("pre",null,[t(o,null,{default:n(()=>[e(`import org.siouan.frontendgradleplugin.infrastructure.gradle.RunNpx
tasks.register<RunNpx>("npxVersion") {
    `),t(r,null,{default:n(()=>[e(`// dependsOn(tasks.named("installNode"))
    // dependsOn(tasks.named("installFrontend"))`)]),_:1}),e(`
    script.set("--version")
}`)]),_:1})])]),_:1})]),_:1})}const Le=_(ae,[["render",ie]]);export{xe as _,Fe as a,we as b,Te as c,ve as d,Se as e,Ge as f,Le as g};
